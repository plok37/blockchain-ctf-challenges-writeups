// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {Script} from "forge-std/Script.sol";
import {ZKChallenge} from "src/ZKChallenge.sol";
import { console } from "forge-std/console.sol";

contract Exploit is Script {
    ZKChallenge zkChallenge;
    uint256 public constant G = 7;
    uint256 public constant P = 23;
    uint256 public constant H = 5;

    constructor() {
        zkChallenge = ZKChallenge(0xB980702A8C8D32bF0F9381AcCFA271779132f1b2);
    }

    function run() public returns (string memory) {

        // Start broadcasting transactions
        
        
        vm.startBroadcast(YOUR_OWN_PUBLIC_ADDRESS);
        console.log("msg.sender", msg.sender);
        // Calculate the commitment: G^secret mod P
        for (uint256 i = 1; i <= 10; i++) {
            console.log("Submitting commitment...");
            uint256 commitment = 22;
            vm.prevrandao(bytes32(uint256(42)));
            zkChallenge.submitCommitment(commitment); // need to be less than 23
            uint256 leftSideEquation = modPow(G, i, P);
            console.log("LeftSide modPow(G, _response, P)", i, leftSideEquation);

            // Get the challenge generated by the contract
            (, uint256 challenge, ,bool verified ) = zkChallenge.proofs(msg.sender);
            console.log("Challenge received from contract:", challenge);
            uint256 challenge1 = uint256(keccak256(abi.encodePacked(block.prevrandao,block.timestamp,msg.sender,commitment))) % P;
            console.log("Challenge calculated by us:", challenge1);

            
            uint256 rightSideEquation = (22 * modPow(H, challenge, P)) % P;

            if (leftSideEquation == rightSideEquation) {
                console.log("Challenge matched with left side equation", rightSideEquation, leftSideEquation);
                console.log("Proof verified with response:", i);
                zkChallenge.verifyProof(i); // Verify the proof with the response
                (,  , ,bool verified2 ) = zkChallenge.proofs(msg.sender);
                console.log("verified", verified2);
                if (verified2) {
                    console.log("Proof already verified");
                } else {
                    console.log("Proof not verified");
                }
                break;
            } else {
                console.log("Challenge did not match with left side equation", rightSideEquation, leftSideEquation);
            }
        }
        string memory flag = zkChallenge.getFlag();
        
        vm.stopBroadcast();
        console.log("Exploit completed. \n\n");
        // console.log("Flag: ", zkChallenge.getFlag());
        return flag;
    }

    function modPow(
        uint256 base,
        uint256 exponent,
        uint256 modulus
    ) internal pure returns (uint256) {
        if (modulus == 0) return 0;
        
        uint256 result = 1;
        base = base % modulus;
        
        while (exponent > 0) {
            if (exponent % 2 == 1) {
                result = (result * base) % modulus;
            }
            base = (base * base) % modulus;
            exponent = exponent / 2;
        }
        
        return result;
    }
}
